import os
import subprocess
import tempfile
import time
from typing import Callable

import ray
from ray.tune.logger import UnifiedLogger
from rich.console import Console

console = Console()

RESOURCES = {
    "cpus": {
        "manycore": 64,
        "xeon-p8": 48,
        "xeon-e5": 28,
        "gaia": 20,
    },
    "gpus": {"gaia": 2},
}


def ray_stats(context):
    """This function prints out relevant statistics that will help a developer
    debug what is going on within ray clusters.
    """

    tempdir = os.getenv("TMPDIR", "None")
    headnode = os.getenv("HEAD_NODE_ADDR", "None")

    # general info
    print("-" * 100)
    print("Ray Cluster Information".center(100))
    print("-" * 100)
    print(f"Dashboard IP: {context.dashboard_url}")
    print(f"Head node: {headnode}")
    print(f"TMPDIR: '{tempdir}'")
    print("Ray cluster resources = ", ray.cluster_resources())
    print("")

    # resources
    nodes = len(ray.nodes())
    cpus = ray.cluster_resources().get("CPU", 0)
    gpus = ray.cluster_resources().get("GPU", 0)
    obj_store_memory = ray.cluster_resources().get("object_store_memory", 0) / 1e9
    memory = ray.cluster_resources().get("memory", 0) / 1e9

    # logging
    print("Resources")
    print(f"Nodes:            {nodes:4}")
    print(f"CPUs:             {cpus:4.0f}")
    print(f"GPUs (Requested): {gpus:4.0f}       Note: Cluster may not have any GPUs...")
    print(f"Object Store Mem: {obj_store_memory:4.0f} GB")
    print(f"Memory:           {memory:4.0f} GB")


def custom_log_creator(custom_path: str, custom_str: str) -> Callable:
    """A custom log creator for Ray.

    Args:
        custom_path (str): Path to save logs to.
        custom_str (str): Name of the log.

    Returns:
        Callable: A callable that is used to build the logger.
    """

    # Custom string only
    logdir_prefix = "{}_".format(custom_str)

    def logger_creator(config):
        if not os.path.exists(custom_path):
            os.makedirs(custom_path)
        logdir = tempfile.mkdtemp(prefix=logdir_prefix, dir=custom_path)
        return UnifiedLogger(config, logdir, loggers=None)

    return logger_creator


def check_logs(log_path: str, printout: str, timeout: int = 250, exitcode="Shutdown Ray"):
    """This is a function to check the logs and verify that a test has completed successfully.  Each experiment will output some sort of :code:`printout` indicating that the test ran successfully (i.e. 'All tests passed!').

    This function will monitor the log files to see if the desired :code:`printout` is found.  If the desired :code:`printout` is not found after the :code:`timeout` period then it will raise an exception to indicate that the test has failed.  The function will also look for a :code:`exitcode` to see if the node has shut down.

    Args:
        log_path (str): Path to the log file to check.
        printout (str): The desired printout statement indicating success.
        timeout (int, optional): The timeout period before throwing an exception. Defaults to 250 seconds.
        exitcode (str, optional): An exit code to determine if Ray has shut down. Defaults to "Shutdown Ray".
    """
    # Set initial variables
    success = False
    timer = 0.0

    # Load logs and look for desired printout
    while (success == False) and (timer < timeout):
        if os.path.isfile(log_path):
            # Read all lines from file
            file_ptr = open(log_path)
            lines = file_ptr.readlines()

            # Check line for success printout
            for line in lines:
                if printout in line:
                    success = True
                    continue
                if exitcode in line:
                    timer = 1000  # force exit
                    break

        time.sleep(0.25)
        timer += 0.25

    # Check flags
    assert (
        success is True
    ), f"Did not find printout: {printout} within time period: {timeout}.  Check whether the node resource was available. If no resource was available, the job simply timed out."


def log_test_wrapper(sbatch_script: str, log_path: str, printout: str, timeout: int = 200):
    """A wrapper function for SLURM's :code:`sbatch` command.  This is used to capture statements from the :code:`sbatch` command.  As each experiment is kicked off it will generate logs which are monitored using the :code:`check_logs()` function.

    Args:
        sbatch_script (str): The sbatch script to execute.
        log_path (str): The logs generated by the experiment.
        printout (str): The prinout to look for to determine success of experiment.
        timeout (int, optional): The experiment's timeout period before throwing an exception. Defaults to 200.

    Raises:
        Exception: Exceptions are thrown for invalid sbatch return values or failed experiments.
    """
    # Remove old logs if they exist
    if os.path.exists(log_path):
        os.remove(log_path)

    # Run the sbatch script and capture output
    results = subprocess.run(["sbatch", sbatch_script], capture_output=True, text=True)

    # Check for error when sent to scheduler
    if results.returncode != 0:
        raise Exception(f"Invalid result: { results.returncode }, Error: {results}")

    # Verify the contents of the log
    check_logs(log_path=log_path, printout=printout, timeout=timeout)
